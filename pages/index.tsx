import type { NextPage } from 'next';
import Head from 'next/head';
import styles from '../styles/Home.module.css';
import { NodeParsers } from './nodestuff';
import { threngine } from './threngine';

/**
 * WebGL 1 > 2
 * varying > in
 * texture2D > texture??
 * gl_FragColor > out var
 */
const frag = `
precision highp float;

#define PI 3.141592653589793238462643383279

uniform float time;
uniform float speed;
uniform float resolution;
uniform vec3 color;
uniform sampler2D image;
uniform float brightness;

varying vec2 vUv;

vec3 lig = normalize(vec3(0.9,0.35,-0.2));

void main() {
  vec2 uvMax = ( 2.0 * asin( sin( 2.0 * PI * vUv ) ) ) / PI;
  vec2 position = vUv * resolution;
  
	vec3 nor = vec3( 0.0, 1.0, 0.0 );
	float dif = max(dot(nor,lig),0.0);
	
	vec3 pos = vec3( position.x, 0.0, position.y );
	
	float timeScale = time * speed;
	
	// lights
	vec3 brdf = vec3(0.0);
	float cc  = 0.55*texture( image, 1.8*0.02*pos.xz + 0.007*timeScale*vec2( 1.0, 0.0) ).x;
	cc += 0.25*texture( image, 1.8*0.04*pos.xz + 0.011*timeScale*vec2( 0.0, 1.0) ).x;
	cc += 0.10*texture( image, 1.8*0.08*pos.xz + 0.014*timeScale*vec2(-1.0,-1.0) ).x;
	cc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + 
		0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-2.4)));

	vec3 col = color * cc;
    
  gl_FragColor = vec4( color * cc * brightness, 1.0 );
}
`;
const vert = `
precision highp float;
precision highp int;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec2 uv2;

in vec2 vUv;
in vec3 vPosition;
in vec3 vNormal;

void main() {
  vUv = uv;
  vPosition = position;
  vNormal = normal;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const nodeParsers: NodeParsers = {
  ...threngine.nodes,
};

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <threngine.Component engine={threngine} parsers={nodeParsers} />
    </div>
  );
};

export default Home;
/* 
[
  chunk:
  uniform sampler2D woahNelly;
  uniform vec4 engineVariable;
  uniform vec3 shaderOnlyVariable;
  in vec2 vUv;

  // A nice to have
  vec2 something() {
    return vUv.y;
  }

  void main(vec2 otro) {
    return engineVariable + shaderOnlyVariable * vUv.x + something() + texture2D(woahNelly, vUv * 2.0);
  }
]

[
  chunk:
  uniform sampler2D image;
  uniform sampler2D normalMap;
  in vec2 vUv;

  void main() {
    vec2 otro = vUv * 2.0;
    vec4 res = texture2D(image, otro);
    vec4 normalRes = texture2D(normalMap, otro);
    return res;

    // Backfilled
    vec4 res_2_result = main_2(otro);
    // Non-backfilled
    vec4 res_2_result = main_2();
  }
]

// inputted into function = inserted at top of the fn? 
[shader1]                    ┌________
          > [add] - texture o output ]
[shader2]                    └‾‾‾‾‾‾‾‾


[shader0] - [shader1]                    ┌________
                      > [add] - texture o output ]
            [shader2]                    └‾‾‾‾‾‾‾‾


// backfill only occurs if previous shader has the vUv attr to backfill?
vec4 res_2_result = shader1(otro) + shader2();

we take the chunk of the last shader
we see it needs texture2d() filled in and backfilled
we walk back to the plus - we merge in the plus result with our own
to get the plus result we look at the plus input a
  - shader1 parsed produces shader1() with list of engine variables it uses
  - we see that we're in a backfilling context for this engine variable so it
    modifies the filler it produces to shader1(vec2 engineVar)
  - now we get back to the plus - and we got shader1(vec2 engineVar) for input a,
    well in this case we're building an expression to input so we can create
    shader1(otro)
  - In the expression case, we can store the backfilling engine variables in the
    context as we compose, and what we intend to backfill them as (aka { vUv: 'otro' })
    and produce the filler expression shader1(otro)

In the case where the backfilled shader itself has an input shader that needs
backfilling

shader1(otro)
vec4 shader1(vec2 otro) {
  vec2 myVuV = otro * 1.0;
  shader0(myVuV * 2.0)
}

We backfill otro into vUv of shader1.
We note that shader1 has an input into its own image.
We set the context of {vUv: 'myVuV * 2.0'} which we might not need to use

texture2D(myImage, vUv) // uses vUv ouright
texture2D(myImage, vUv * 2.0) // uses engine var vUv in expression
texture2D(myImage, vec2(2.0)) // doesnt use engine var at all. if we want to
                                backfill this, it's a special case knowledge
                                that texture2D(image, uv) === vUv in filling
                                shaders. It's not that texture2D(image, uv) "uv"
                                becomes the thing we look for in the previous
                                shader. It's that we have to know that texture2D(image, ...) =
                                start backfilling context vUv (and then ideally
                                the "out" from the vertex shader is the var to
                                backfill)

[shader1]                   ┌________
          > [add] - texture o output ]
[shader2]                   └‾‾‾‾‾‾‾‾

output: { inputs: { texture2D, strategy: 'replaceVuVImage', backfillers: backfill('vUv') } }

// First we need to get the final filler expression for this hole
const { ast, fillerExpression } = compose(graph.inputs(vUv), strategy)

Then we get to add
a + b
inputs: { a: { strategy: () => replace(aAstNode, exprAst) } }
const { ast, fillerExpression } = compose(graph.inputs(a), strategy)
// and fill it in for our node
ast = fill(ast, fillerExpression, inputs[0])

const { ast, fillerExpression } = compose(inputs, )

// Back up at output, then we need to fill the hole
ast = fill(ast, fillerExpression, inputs[0])
// which results in vec4 shader1() + shader2() 

*/
